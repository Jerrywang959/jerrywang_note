{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 这是jerrywang的云笔记，主要用于个人整理知识和复习，很多东西都是直接在网上直接copy过来的，若有侵权，请联系w767729940@gmail.com删除。 相关链接 个人博客 gitee page托管页面(国内访问较佳) github page托管页面 gitbook托管页面 为什么用gitbook 记笔记的目的本身就是在有需要时检索，放在公网上易于访问，也有可能帮助到有需要的人。 通过gitbook撰写的非数据库markdown文档，更加具有掌控感。 web应用易于扩展和移动，且服务器在国外可以无备案使用域名。 欢迎pr 若有书写错误或者补充的地方，可以fork此项目github主页修改并提交push request，只需要修改markdown文件即可。 License CC0-1.0 © Jerry Wang Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-21 22:10:53 "},"Regular_Expression.html":{"url":"Regular_Expression.html","title":"Regular Expression","summary":"正则表达式的学习笔记","keywords":"","body":"Regular Expression 定义 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 基本结构 限定符 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo 能匹配 \"z\" 以及 \"zoo\"。 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 、 \"does\" 中的 \"does\" 、 \"doxy\" 中的 \"do\" 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 {n,m} m 和 n 均为非负整数，其中n 最少匹配 n 次且最多匹配 m 次。例如，\"o{1,3}\" 将匹配 \"fooooood\" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 特殊字符 特殊字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\\n' 或 '\\r'。要匹配 $ 字符本身，请使用 \\$。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\(。 * 匹配前面的子表达式零次或多次。要匹配 字符，请使用 `\\`。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 \\[。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\\n' 匹配换行符。序列 '\\\\' 匹配 \"\\\"，而 '\\(' 则匹配 \"(\"。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \\^。 { 标记限定符表达式的开始。要匹配 {，请使用 \\{。 | 指明两项之间的一个选择。要匹配 |，请使用 \\|。 非打印字符 字符 描述 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 定位符 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。 举例 匹配所有正整数，不包括0 [1-9][0-9]* 匹配1~99 [1-9][0-9]? 匹配章节 ^Chapter [1-9][0-9]{0,1}$ 匹配Chapter中的apt，但不匹配aptitude中的apt \\Bapt 贪婪匹配与非贪婪匹配 *、+ 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 RUNOOB-菜鸟教程 匹配RUNOOB-菜鸟教程 而匹配 还不懂的 非捕获元 缓存 反向选择 参考文献 菜鸟教程：正则表达式 - 语法 Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 19:28:51 "},"julia_study/":{"url":"julia_study/","title":"README","summary":"Julia_study group的介绍","keywords":"","body":"Introduction 这一group是jerrywang的julia学习笔记 为什么选择Julia 它真的很好：快、学起来没那么难 专为科学计算而生，甚至对标金融，跟我的方向有些相符 我并不精通任何一门语言，机会成本很低，刚开始学习，希望学习一门有发展潜力的语言。 Julia环境 系统环境 Pkg环境 (@v1.4) pkg> st Status `~/.julia/environments/v1.4/Project.toml` [c52e3926] Atom v0.12.10 [fbb218c0] BSON v0.2.5 [6e4b80f9] BenchmarkTools v0.5.0 [ad839575] Blink v0.12.3 [336ed68f] CSV v0.6.1 [3895d2a7] CUDAapi v4.0.0 [c5f51814] CUDAdrv v6.2.2 [be33ccc6] CUDAnative v3.0.4 [5ae59095] Colors v0.12.0 [3a865a2d] CuArrays v2.0.1 [5789e2e9] FileIO v1.2.4 [587475ba] Flux v0.10.4 [0c68f7d7] GPUArrays v3.1.0 [7073ff75] IJulia v1.21.2 [916415d5] Images v0.22.2 [e5e0dc1b] Juno v0.8.1 [eb30cadb] MLDatasets v0.5.1 [47be7bcc] ORCA v0.3.1 [d96e819e] Parameters v0.12.0 [f0f68f2c] PlotlyJS v0.13.1 [91a5bcdd] Plots v1.0.11 [438e738f] PyCall v1.91.4 [1d978283] TensorFlow v0.11.0 [b8865327] UnicodePlots v1.1.0 [0f1e0344] WebIO v0.8.13 [de0858da] Printf [9a3f8284] Random [10745b16] Statistics 参考资料 在这里列出该group下的所有参考资料 官方文档 Flux官方文档 WebIO官方文档 教学视频 Julia acadamy 论坛交流 Plots绘图中乱码 Github Issue Error with unicode labels in GR backend 百科 维基百科-LU分解 维基百科-QR分解 Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 22:39:11 "},"julia_study/Base/":{"url":"julia_study/Base/","title":"Base","keywords":"","body":"Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 19:28:52 "},"julia_study/Base/Basic_gammer.html":{"url":"julia_study/Base/Basic_gammer.html","title":"Basic_gammer","summary":"基本命令","keywords":"","body":"Basic Gammer 多行注释 #= This is a multi-line comment 这是多行注释 =# 基本运算符号 余数% julia> 10 % 3 1 julia> 25%4 1 语句连接符号 && 意思是 \"和\" Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 19:28:52 "},"julia_study/Base/String.html":{"url":"julia_study/Base/String.html","title":"String","summary":"Julia中对于字符串的操作","keywords":"","body":"String 生成字符串 julia> a=\"hello, world\" \"hello, world\" 多行字符串 并且可以包含字符串内的双引号 julia> a=\"\"\" hello, world, I am julia \"\"\" \" hello,\\nworld,\\nI am julia \" 字符串内使用变量的实际数值 用$ julia> name = \"Jane\" \"Jane\" julia> println(\"Hello, my name is $name.\") Hello, my name is Jane. 合并字符串 julia> s3 = \"How many cats \"; julia> s4 = \"is too many cats?\"; julia> string(s3, s4) \"How many cats is too many cats?\" julia> s3*s4 \"How many cats is too many cats?\" julia> \"$s3$s4\" \"How many cats is too many cats?\" Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 19:28:52 "},"julia_study/Base/DataStructure.html":{"url":"julia_study/Base/DataStructure.html","title":"DataStructure","summary":"Julia的数据结构","keywords":"","body":"DataStructure Tuples 创建元组 (item1, item2, ...) julia> myfavoriteanimals = (\"penguins\", \"cats\", \"sugargliders\") (\"penguins\", \"cats\", \"sugargliders\") 索引元组 julia是从1开始索引 julia> myfavoriteanimals[1] \"penguins\" 不能改变元组 因为它是immutable的 julia> myfavoriteanimals[1] = \"otters\" ERROR: MethodError: no method matching setindex!(::Tuple{String,String,String}, ::String, ::Int64) Stacktrace: [1] top-level scope at REPL[10]:1 NamedTuples 和一般的元组一样，只是把元组内部的每个元素都有一个name，用数字或者.name索引 (name1 = item1, name2 = item2, ...) julia> myfavoriteanimals = (bird = \"penguins\", mammal = \"cats\", marsupial = \"sugargliders\") (bird = \"penguins\", mammal = \"cats\", marsupial = \"sugargliders\") julia> myfavoriteanimals[1] \"penguins\" julia> myfavoriteanimals.bird \"penguins\" Dictionary 创建字典 Dict(key1 => value1, key2 => value2, ...)，字典的值需是相同的类型 julia> myphonebook = Dict(\"Jenny\" => \"867-5309\", \"Ghostbusters\" => \"555-2368\") Dict{String,String} with 2 entries: \"Jenny\" => \"867-5309\" \"Ghostbusters\" => \"555-2368\" 读取字典内容 julia> myphonebook[\"Jenny\"] \"867-5309\" 增加字典内容 julia> myphonebook[\"Kramer\"]=\"555-FILK\" \"555-FILK\" julia> myphonebook Dict{String,String} with 3 entries: \"Jenny\" => \"867-5309\" \"Kramer\" => \"555-FILK\" \"Ghostbusters\" => \"555-2368\" 删除一个键值对应并返回值 使用pop! julia> pop!(myphonebook, \"Kramer\") \"555-FILK\" julia> myphonebook Dict{String,String} with 2 entries: \"Jenny\" => \"867-5309\" \"Ghostbusters\" => \"555-2368\" Arrays 与Tuples不同，Arrays是可变的；与Dictionary不同，Arrays是有序的 [item1, item2, ...] 创建Arrays 返回的类型中，第一个“String”表示Arrays内元素的类型，1表示Arrays的维度 julia> myfriends = [\"Ted\", \"Robyn\", \"Barney\", \"Lily\", \"Marshall\"] 5-element Array{String,1}: \"Ted\" \"Robyn\" \"Barney\" \"Lily\" \"Marshall\" julia> fibonacci = [1, 1, 2, 3, 5, 8, 13] 7-element Array{Int64,1}: 1 1 2 3 5 8 13 julia> mixture = [1, 1, 2, 3, \"Ted\", \"Robyn\"] 6-element Array{Any,1}: 1 1 2 3 \"Ted\" \"Robyn\" 索引Arrays 用数字所在的序号索引 julia> myfriends[3] \"Barney\" 修改Arrays某一索引 julia> myfriends[3] = \"Baby Bop\" \"Baby Bop\" 增加和减少Arrays push!,pop! julia> push!(fibonacci, 21) 8-element Array{Int64,1}: 1 1 2 3 5 8 13 21 julia> pop!(fibonacci) 21 julia> fibonacci 7-element Array{Int64,1}: 1 1 2 3 5 8 13 复杂的Arrays 可以是多个维度的Arrays，也可以是Arrays的Arrays julia> favorites = [[\"koobideh\", \"chocolate\", \"eggs\"],[\"penguins\", \"cats\", \"sugargliders\"]] 2-element Array{Array{String,1},1}: [\"koobideh\", \"chocolate\", \"eggs\"] [\"penguins\", \"cats\", \"sugargliders\"] julia> numbers = [[1, 2, 3], [4, 5], [6, 7, 8, 9]] 3-element Array{Array{Int64,1},1}: [1, 2, 3] [4, 5] [6, 7, 8, 9] julia> rand(4, 3) 4×3 Array{Float64,2}: 0.580342 0.840483 0.590226 0.612861 0.801844 0.859797 0.742443 0.590106 0.649077 0.477118 0.72509 0.342509 julia> rand(4, 3, 2) 4×3×2 Array{Float64,3}: [:, :, 1] = 0.888219 0.384393 0.0619398 0.473101 0.204024 0.784434 0.72608 0.92305 0.100044 0.815554 0.161155 0.416701 [:, :, 2] = 0.305238 0.530652 0.74287 0.484455 0.0904463 0.105327 0.0632765 0.818537 0.704337 0.152749 0.0189906 0.120929 创建副本防止绑定更新 使用=生产的新Arrays，内存地址上和原来的Arrays是相同的，因此会同时更新 julia> fibonacci 7-element Array{Int64,1}: 1 1 2 3 5 8 13 julia> somenumbers = fibonacci 7-element Array{Int64,1}: 1 1 2 3 5 8 13 julia> somenumbers[1] = 404 404 julia> fibonacci 7-element Array{Int64,1}: 404 1 2 3 5 8 13 若要防止此情况，使用copy创建新的Arrays julia> fibonacci 7-element Array{Int64,1}: 1 1 2 3 5 8 13 julia> somemorenumbers = copy(fibonacci) 7-element Array{Int64,1}: 1 1 2 3 5 8 13 julia> somemorenumbers[1] = 404 404 julia> fibonacci 7-element Array{Int64,1}: 1 1 2 3 5 8 13 Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 19:28:52 "},"julia_study/Base/Control_flow.html":{"url":"julia_study/Base/Control_flow.html","title":"Control_flow","summary":"Julia控制句法","keywords":"","body":"Control flow While循环语句 while *condition* *loop body* end 举例 while n 1 2 3 4 5 6 7 8 9 10 10 myfriends = [\"Ted\", \"Robyn\", \"Barney\", \"Lily\", \"Marshall\"] i = 1 while i Hi Ted, it's great to see you! Hi Robyn, it's great to see you! Hi Barney, it's great to see you! Hi Lily, it's great to see you! Hi Marshall, it's great to see you! For循环语句 for *var* in *loop iterable* *loop body* end 举例 myfriends = [\"Ted\", \"Robyn\", \"Barney\", \"Lily\", \"Marshall\"] for friend in myfriends println(\"Hi $friend, it's great to see you!\") end >Hi Ted, it's great to see you! Hi Robyn, it's great to see you! Hi Barney, it's great to see you! Hi Lily, it's great to see you! Hi Marshall, it's great to see you! m, n = 5, 5 A = fill(0, (m, n)) >5×5 Array{Int64,2}: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 for i in 1:m for j in 1:n A[i, j] = i + j end end A >5×5 Array{Int64,2}: 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 5 6 7 8 9 6 7 8 9 10 for语句的其他形式 B = fill(0, (m, n)) >5×5 Array{Int64,2}: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 for i in 1:m, j in 1:n B[i, j] = i + j end B >5×5 Array{Int64,2}: 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 5 6 7 8 9 6 7 8 9 10 C = [i + j for i in 1:m, j in 1:n] >5×5 Array{Int64,2}: 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 5 6 7 8 9 6 7 8 9 10 If条件语句 if *condition 1* *option 1* elseif *condition 2* *option 2* else *option 3* end 举例 julia> N =4 4 julia> if (N % 3 == 0) && (N % 5 == 0) # `&&` means \"AND\"; % computes the remainder after division println(\"FizzBuzz\") elseif N % 3 == 0 println(\"Fizz\") elseif N % 5 == 0 println(\"Buzz\") else println(N) end 4 if语句的其他形式 三元运算符 a ? b : c 这等同于 if a b else c end 使用语句连接符 julia> x=3 3 julia> (x > 0) && error(\"x cannot be greater than 0\") ERROR: x cannot be greater than 0 Stacktrace: [1] error(::String) at ./error.jl:33 [2] top-level scope at REPL[8]:1 julia> x=-4 -4 julia> (x > 0) && error(\"x cannot be greater than 0\") false julia> true || println(\"hi\") true julia> false || println(\"hi\") hi Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 19:28:52 "},"julia_study/Base/Functions.html":{"url":"julia_study/Base/Functions.html","title":"Functions","summary":"函数的基本用法","keywords":"","body":"Functions Declare a function 标准形式 用 fuction … end 声明一个函数 julia> function sayhi(name) println(\"Hi $name, it's great to see you!\") end sayhi (generic function with 1 method) julia> sayhi(\"C-3PO\") Hi C-3PO, it's great to see you! 简介形式 julia> sayhi2(name) = println(\"Hi $name, it's great to see you!\") sayhi2 (generic function with 1 method) julia> sayhi2(\"R2D2\") Hi R2D2, it's great to see you! 匿名函数形式 julia> sayhi3 = name -> println(\"Hi $name, it's great to see you!\") #3 (generic function with 1 method) julia> sayhi3(\"Chewbacca\") Hi Chewbacca, it's great to see you! Duck-typing If it walks like a duck and it quacks like a duck, then it must be a duck 函数方法不依赖于对象的类型，其他类型的对象会尽可能地调用方法，若能调用成功，则函数对于此类型的对象可用。julia的函数即是这样的。 julia> function sayhi(name) println(\"Hi $name, it's great to see you!\") end sayhi (generic function with 1 method) julia> sayhi(55595472) Hi 55595472, it's great to see you! julia> f(x)=x^2 f (generic function with 1 method) julia> f(\"hi\") \"hihi\" julia> f(rand(3,3)) 3×3 Array{Float64,2}: 0.738116 0.982017 0.529161 0.339603 0.528315 0.473647 0.494267 0.500296 0.365849 julia> f(rand(3)) ERROR: MethodError: no method matching ^(::Array{Float64,1}, ::Int64) Closest candidates are: ^(::Float16, ::Integer) at math.jl:885 ^(::Regex, ::Integer) at regex.jl:712 ^(::Missing, ::Integer) at missing.jl:155 ... Stacktrace: [1] macro expansion at ./none:0 [inlined] [2] literal_pow at ./none:0 [inlined] [3] f(::Array{Float64,1}) at ./REPL[4]:1 [4] top-level scope at REPL[7]:1 Mutating vs. non-mutating functions 带!的函数会改变输入的参数，不带!的函数不会改变输入的参数 julia> v = [3, 5, 2] 3-element Array{Int64,1}: 3 5 2 julia> sort(v);v 3-element Array{Int64,1}: 3 5 2 julia> sort!(v);v 3-element Array{Int64,1}: 2 3 5 higher order functions 高阶函数 map 把一个函数分别传递到一个数据结构中的每一个数，并映射到函数值 map(f, [1, 2, 3])将得到[f(1), f(2), f(3)] julia> map(x -> x^3, [1, 2, 3]) 3-element Array{Int64,1}: 1 8 27 broadcast broadcast(f, [1, 2, 3])将得到f.([1, 2, 3]) julia> f(x)=x^2 f (generic function with 1 method) julia> A = [i + 3*j for j in 0:2, i in 1:3] 3×3 Array{Int64,2}: 1 2 3 4 5 6 7 8 9 julia> A .+ 2 .* f.(A) ./ A 3×3 Array{Float64,2}: 3.0 6.0 9.0 12.0 15.0 18.0 21.0 24.0 27.0 julia> broadcast(x -> x + 2 * f(x) / x, A) 3×3 Array{Float64,2}: 3.0 6.0 9.0 12.0 15.0 18.0 21.0 24.0 27.0 Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 19:28:52 "},"julia_study/Base/Packages.html":{"url":"julia_study/Base/Packages.html","title":"Package","summary":"Julia pkg的使用和管理","keywords":"","body":"Packages julia有专门的包管理工具——Pkg，可以用 ]进入pkg管理页面，也可以使用using Pkg Pkg.xxx来管理Pkg (@v1.4) pkg> add Colors Updating registry at `~/.julia/registries/General` Updating git-repo `https://github.com/JuliaRegistries/General.git` Resolving package versions... Updating `~/.julia/environments/v1.4/Project.toml` [no changes] Updating `~/.julia/environments/v1.4/Manifest.toml` [no changes] julia> using Colors julia> palette = distinguishable_colors(100) 100-element Array{RGB{N0f8},1} with eltype RGB{FixedPointNumbers.Normed{UInt8,8}}: RGB{N0f8}(0.0,0.0,0.0) RGB{N0f8}(1.0,1.0,0.455) RGB{N0f8}(1.0,0.608,1.0) RGB{N0f8}(0.0,0.827,1.0) RGB{N0f8}(0.886,0.388,0.051) RGB{N0f8}(0.0,0.494,0.0) RGB{N0f8}(0.0,0.314,0.902) RGB{N0f8}(0.675,0.0,0.278) ⋮ RGB{N0f8}(0.855,0.0,0.247) RGB{N0f8}(0.18,0.129,0.141) RGB{N0f8}(0.0,0.345,0.082) RGB{N0f8}(1.0,0.557,0.114) RGB{N0f8}(0.4,0.455,0.694) RGB{N0f8}(0.0,0.804,0.678) RGB{N0f8}(0.0,0.498,0.388) RGB{N0f8}(0.6,0.435,0.239) julia> rand(palette, 3, 3) 3×3 Array{RGB{N0f8},2} with eltype RGB{FixedPointNumbers.Normed{UInt8,8}}: RGB{N0f8}(0.196,0.212,0.024) … RGB{N0f8}(0.62,0.62,0.467) RGB{N0f8}(0.0,0.498,0.388) RGB{N0f8}(0.655,0.525,0.0) RGB{N0f8}(0.306,0.427,0.314) RGB{N0f8}(1.0,0.306,0.78) RGB的向量在nteract中输出会自动渲染成颜色，而在repl不会。 Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 19:28:52 "},"julia_study/Base/Plotting.html":{"url":"julia_study/Base/Plotting.html","title":"Plotting","summary":"Julia 的画图方法","keywords":"","body":"Plotting Plots 使用“Plots”这一Packages画图，Plots本质上也只是一个前端的工具，真正渲染制作出图片的其实是后端的一些程序。 后端程序 GR 输入以下的命令使用GR作为后端 julia> using Plots julia> gr() Plots.GRBackend() julia> plot(rand(10)) 但GR对中文的图像标注并不友好，我在deepin linux 15.11上无法解决这一问题，因此选择了其他的后端 PlotlyJS 这一后端支持中文输入，需要额外安装PlotlyJS、WebIO和ORCA 安装和配置 ]add PlotlyJS ORCA WebIO 若从repl中画图，会自动弹出jupyter的Blink窗口，不需要配置WebIO。 若从jupyter中画图，则需要安装对应的插件 using WebIO WebIO.install_jupyter_nbextension() jupyterlab则使用以下的命令 using WebIO WebIO.install_jupyter_nbextension() 以上命令最好在repl中进行，并杀死jupyter进程 nteract(0.22.4)貌似还未适配WebIO.jl，但安装jupyter 的插件后，不影响画图结果。 使用PlotlyJS 使用如下命令把plotlyjs作为plots的后端 using Plots plotlyjs() 这会一些warning，不知道为什么，但不影响画图结果 举例 UnicodePlots 安装 ] add UnicodePlots 使用 unicodeplots() 画出来效果如下 unicodeplots() p1 = plot(x, x.^2) title!(\"你好\") 这样的粗略的画图便于在命令行中展示，而且支持中文。 画图命令 plot 折线图 using Plots plotlyjs() x = [14.4, 14.5, 14.8, 15.2, 15.5, 15.8]; y = [45000, 20000, 15000, 5000, 400, 17]; plot(x,y,title=\"test\") scatter 散点图 using Plots plotlyjs() x = [14.4, 14.5, 14.8, 15.2, 15.5, 15.8]; y = [45000, 20000, 15000, 5000, 400, 17]; scatter(x, y, label=\"points\") using Plots plotlyjs() x = [14.4, 14.5, 14.8, 15.2, 15.5, 15.8]; y = [45000, 20000, 15000, 5000, 400, 17]; plot(x,y,title=\"test\") scatter!(x, y, label=\"points\") 后面的!表示在原图的基础上继续画图，而非生成一个新的图像 一些参数 参数可以直接在plot函数的内部加上，也可以在画图之后以!函数的形式加上 using Plots plotlyjs() x = [14.4, 14.5, 14.8, 15.2, 15.5, 15.8]; y = [45000, 20000, 15000, 5000, 400, 17]; plot(x,y,xlabel=\"这是x轴\",ylabel=\"这是y轴\",title=\"这是标题\") using Plots plotlyjs() x = [14.4, 14.5, 14.8, 15.2, 15.5, 15.8]; y = [45000, 20000, 15000, 5000, 400, 17]; plot(x,y) xlabel!(\"这是x轴\") ylabel!(\"这是y轴\") title!(\"这是标题1\") xflip! xflip!()翻转x轴，yflip!()反转y轴 多个子图 用一个变量表示一个子图，最后用plot连接起来 using Plots x=1:10 plotlyjs() p1 = plot(x, x.+1) p2 = plot(x, x.^2) p3 = plot(x, x.^3) p4 = plot(x, x.^4) plot(p1, p2, p3, p4, layout = (2, 2)) Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 19:28:52 "},"julia_study/Base/Multiple_Dispatch.html":{"url":"julia_study/Base/Multiple_Dispatch.html","title":"Multiple_Dispatch","keywords":"","body":"Multiple Dispatch Multiple Dispatch是和duck-type相对应的，多重分派即是对于同名函数，不同的变量类型给予不同的方法 Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-21 16:13:06 "},"julia_study/Base/Factorizations.html":{"url":"julia_study/Base/Factorizations.html","title":"Factorizations","summary":"Julia因式分解函数","keywords":"","body":"Factorizations 因式分解相关函数，出现了一些我并不能看懂的线性代数方法。 LU factorizations 在线性代数与数值分析中，LU分解是矩阵分解的一种，将一个矩阵分解为一个下三角矩阵和一个上三角矩阵的乘积，有时需要再乘上一个置换矩阵。LU分解可以被视为高斯消元法的矩阵形式。在数值计算上，LU分解经常被用来解线性方程组、且在求反矩阵和计算行列式中都是一个关键的步骤。 PA=LU PA = LU PA=LU AAA 是被分解的矩阵，PPP 是置换矩阵，LLL 是下三角矩阵，UUU是上三角矩阵。 使用函数lu()进行LU分解，using lufact. julia> A = rand(3, 3) 3×3 Array{Float64,2}: 0.111894 0.730218 0.283805 0.66003 0.487591 0.945071 0.644679 0.0101276 0.862639 julia> using LinearAlgebra julia> Alu = lu(A) LU{Float64,Array{Float64,2}} L factor: 3×3 Array{Float64,2}: 1.0 0.0 0.0 0.169529 1.0 0.0 0.976742 -0.719817 1.0 U factor: 3×3 Array{Float64,2}: 0.66003 0.487591 0.945071 0.0 0.647557 0.123588 0.0 0.0 0.0285094 使用.P,.L,.U调用分解后的P矩阵,L矩阵或U矩阵 julia> Alu.P 3×3 Array{Float64,2}: 0.0 1.0 0.0 1.0 0.0 0.0 0.0 0.0 1.0 julia> Alu.L 3×3 Array{Float64,2}: 1.0 0.0 0.0 0.169529 1.0 0.0 0.976742 -0.719817 1.0 julia> Alu.U 3×3 Array{Float64,2}: 0.66003 0.487591 0.945071 0.0 0.647557 0.123588 0.0 0.0 0.0285094 Julia的多重分派可以使得对一个被分解后的矩阵整体进行某些操作，并得到相同结果。以下例子包括了矩阵“除法”和求行列式 julia> b=rand(3) 3-element Array{Float64,1}: 0.7071667357222131 0.14187417923162382 0.8633724393268927 julia> A\\b 3-element Array{Float64,1}: -55.646676986062815 -7.08892173833099 42.67067045131066 julia> Alu\\b 3-element Array{Float64,1}: -55.646676986062815 -7.08892173833099 42.67067045131066 julia> det(A) ≈ det(Alu) true QR factorizations QR分解法是三种将矩阵分解的方式之一。这种方式，把矩阵分解成一个正交矩阵与一个上三角矩阵的积。QR分解经常用来解线性最小二乘法问题。QR分解也是特定特征值算法即QR算法的基础。 A=QR A=QR A=QR AAA 为被分解的矩阵，QQQ是正交矩阵，RRR是上三角矩阵 使用qr()对矩阵进行QR分解操作，using qrfact julia> using LinearAlgebra julia> Aqr = qr(A) LinearAlgebra.QRCompactWY{Float64,Array{Float64,2}} Q factor: 3×3 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}: -0.120395 0.891848 0.436018 -0.710173 0.229519 -0.665563 -0.693656 -0.389779 0.605734 R factor: 3×3 Array{Float64,2}: -0.929392 -0.441214 -1.30371 0.0 0.759207 0.133785 0.0 0.0 0.0172691 使用.Q,.R调用分解后的QQQ矩阵,RRR矩阵 julia> Aqr.Q 3×3 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}: -0.120395 0.891848 0.436018 -0.710173 0.229519 -0.665563 -0.693656 -0.389779 0.605734 julia> Aqr.R 3×3 Array{Float64,2}: -0.929392 -0.441214 -1.30371 0.0 0.759207 0.133785 0.0 0.0 0.0172691 Eigendecompositions 特征分解，奇异值分解，Hessenberg分解和Schur分解的结果are all stored in Factorization types1. 用eigen求解矩阵特征值和特征向量 julia> Asym = A + A' 3×3 Array{Float64,2}: 0.223788 1.39025 0.928484 1.39025 0.975182 0.955199 0.928484 0.955199 1.72528 julia> AsymEig = eigen(Asym) Eigen{Float64,Float64,Array{Float64,2},Array{Float64,1}} values: 3-element Array{Float64,1}: -0.8530493828857049 0.5600188449031531 3.21727866868319 vectors: 3×3 Array{Float64,2}: 0.812969 -0.337866 -0.474266 -0.57692 -0.577869 -0.577262 -0.0790263 0.74291 -0.664711 julia> AsymEig.values 3-element Array{Float64,1}: -0.8530493828857049 0.5600188449031531 3.21727866868319 julia> AsymEig.vectors 3×3 Array{Float64,2}: 0.812969 -0.337866 -0.474266 -0.57692 -0.577869 -0.577262 -0.0790263 0.74291 -0.664711 Once again, when the factorization is stored in a type, we can dispatch on it and write specialized methods that exploit the properties of the factorization, e.g. that A−1=(VΛV−1)−1=VΛ−1V−1 A^{-1}=(V\\Lambda V^{-1})^{-1}=V\\Lambda^{-1}V^{-1}A​−1​​=(VΛV​−1​​)​−1​​=VΛ​−1​​V​−1​​.2 julia> inv(AsymEig)*Asym 3×3 Array{Float64,2}: 1.0 1.66533e-15 -3.88578e-16 -6.66134e-16 1.0 0.0 8.88178e-16 -8.88178e-16 1.0 Special matrix structures 矩阵结构在线性代数中非常重要。要了解它的重要性，让我们使用更大的线性系统 issymmetric检验一个矩阵是否是对称阵，并返回true or false julia> using LinearAlgebra julia> n = 1000; julia> A = randn(n,n); julia> Asym = A + A'; julia> issymmetric(Asym) true julia> Asym_noisy = copy(Asym); julia> Asym_noisy[1,2] += 5eps(); julia> issymmetric(Asym_noisy); false 1. 我不太理解，因此保留英文 ↩ 2. 这句话我也不懂，还是保留了英文 ↩ Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 19:28:52 "},"julia_study/LinearAlgebra/":{"url":"julia_study/LinearAlgebra/","title":"LinearAlgebra","keywords":"","body":"Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 19:28:52 "},"julia_study/LinearAlgebra/Basic.html":{"url":"julia_study/LinearAlgebra/Basic.html","title":"Basic","summary":"最最最基本的线性代数运算","keywords":"","body":"Basic 生成向量或矩阵 julia> A = rand(1:4,3,3) 3×3 Array{Int64,2}: 4 2 4 4 2 3 1 2 2 julia> x = fill(1.0, (3,)) 3-element Array{Float64,1}: 1.0 1.0 1.0 乘和转置 julia> b = A*x 3-element Array{Float64,1}: 10.0 9.0 5.0 julia> A' 3×3 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}: 4 4 1 2 2 2 4 3 2 julia> transpose(A) 3×3 LinearAlgebra.Transpose{Int64,Array{Int64,2}}: 4 4 1 2 2 2 4 3 2 julia> A'A 3×3 Array{Int64,2}: 33 18 30 18 12 18 30 18 29 \\ 从方程 $Ax=b$ 求解x，其中$A$为方阵 julia> A\\b 3-element Array{Float64,1}: 1.0 1.0 1.0 如果/前是一个过度确定的线性系统(least squares solution)(高矩阵)，我们会得到一个最小二乘法的解。 julia> Atall = rand(3, 2) 3×2 Array{Float64,2}: 0.509259 0.199434 0.927561 0.92623 0.0378898 0.165023 julia> Atall\\b 2-element Array{Float64,1}: 17.8463824370428 -6.596395027758899 如果是秩不足的最小二乘问题，则会得到最小范数最小二乘解 julia> v = rand(3) 3-element Array{Float64,1}: 0.5216257841057546 0.5350262816162525 0.6433750280513937 julia> rankdef = hcat(v, v) 3×2 Array{Float64,2}: 0.521626 0.521626 0.535026 0.535026 0.643375 0.643375 julia> rankdef\\b 2-element Array{Float64,1}: 6.813056253069082 6.81305625306908 如果\\前面的是未定的问题(underdetermined solution)(短矩阵) julia> bshort = rand(2) 2-element Array{Float64,1}: 0.8352714299155983 0.8146631376007327 julia> Ashort = rand(2, 3) 2×3 Array{Float64,2}: 0.287498 0.153943 0.231742 0.479411 0.0772732 0.197439 julia> Ashort\\bshort 3-element Array{Float64,1}: 0.7691000398938104 1.434562771848009 1.697210113213556 内积、外积、叉积 内积 julia> v = [1,2,3] 3-element Array{Int64,1}: 1 2 3 julia> v'v 14 叉积 julia> using LinearAlgebra julia> cross_v=cross(v,v) 3-element Array{Int64,1}: 0 0 0 外积 julia> outer_v=reshape(kron(v,v),length(v),length(v)) 3×3 Array{Int64,2}: 1 2 3 2 4 6 3 6 9 Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 19:28:52 "},"julia_study/Flux/":{"url":"julia_study/Flux/","title":"Flux","summary":"Julia Flux Pkg的学习笔记","keywords":"","body":"Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 19:28:52 "},"julia_study/Flux/Functions.html":{"url":"julia_study/Flux/Functions.html","title":"Functions","summary":"Julia Flux Pkg中的函数用法","keywords":"","body":"Fuctions gradient 求导函数，亦称求梯度函数 基本用法 df(x) = gradient(f, x) df为导函数，f为原函数，x为求导变量 gradient(f, [2, 1], [2, 0]) f为原函数，后面两个数组为函数的两个参数向量，该语句返回函数在某一点的导数（梯度） gs=gradient(params(x, y)) do f(x, y) end 通过处理参数集合params来获取导数 params 返回函数参数的函数 update! 按照一定的方式更新网络参数 Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 19:28:52 "},"Course_study/":{"url":"Course_study/","title":"README","summary":null,"keywords":"","body":"Introduction 课程学习笔记 Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 22:29:25 "},"Course_study/DM-ML/":{"url":"Course_study/DM-ML/","title":"DM-ML","summary":null,"keywords":"","body":"Introduction 课程名称：数据挖掘和机器学习 Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 19:28:51 "},"Course_study/DM-ML/Homework.html":{"url":"Course_study/DM-ML/Homework.html","title":"Homework","summary":"作业todo清单","keywords":"","body":"2020-2-20 Read Home Reading 1A: Mathematics for Machine LearningSend the page numbers to ta wherever you can't understand. TA Will collect the information Send a life photo to ta with your name due day : Apr.23,10pm 发到TA邮箱 Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-21 21:42:55 "},"Course_study/Game_Thoery/":{"url":"Course_study/Game_Thoery/","title":"Game_Thoery","summary":"课程简介","keywords":"","body":"Intruduction 课程教材： Steven Tadelis, Game Theory An Introduction Princeton University press, 2013 博弈论不是对现实的描述，而是一种分析方法。 Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 22:26:59 "},"Course_study/Game_Thoery/Basics.html":{"url":"Course_study/Game_Thoery/Basics.html","title":"Basics","summary":"学习博弈论需要的基础知识","keywords":"","body":"概率论基础 期望效用 事件概率之间的关系 互斥、互补、条件概率 Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 19:28:51 "},"Course_study/Financial_Lecture/":{"url":"Course_study/Financial_Lecture/","title":"Financial_Lecture","keywords":"","body":"课程目标 课程旨在搭建起金融理论与金融实践的桥梁,毎周定期邀请金融界知名高管进行系列主题讲座,介绍资本市场、金融制度、投资银行、基金、融资租赁、风险管理、互联网金融等方面的发展现状。为学生确定选择研究方向、职业规划提供参考和借鉴通过这门课的学习,学生将能够: 了解不同类型的金融机构的运行机制和特征。 了解金融机构中的各种职位所需的金融知识和能力 对现实世界中发生的经济和金融事件进行分析,有自己的观点和立场 课程要求 三次以上旷课0分 期末学习报告：结合嘉宾讲座内容对自己感兴趣的金融细分领域进行深入分析与探讨,明确这个行业的发展趋势前景以及为什么自己对这个细分行业感兴趣。 评分：20%出勤和互动+80%报告 Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 22:41:51 "},"Course_study/Financial_Lecture/Learn_from_ruixin.html":{"url":"Course_study/Financial_Lecture/Learn_from_ruixin.html","title":"Learn_from_ruixin","keywords":"","body":"一些需要知道的 在美国上市并不是什么了不起的事情，钱多就可以。 瑞幸咖啡的故事 中国之前现状 咖啡贵 买不方便，没有外卖 为什么投瑞幸 中国市场大 收入增长快，扩招快 新零售：把商业用互联网再做一遍 用互联网的方式做一遍,和传统方式有什么不同呢？ 资本模式不同互联网企业起步即可获得充足的、甚至源源不断的资金;这些资金可以支持直接对领导品牌发起挑战。这是传统模式难以具备的. 发展逻辑不同传统企业往往需要先小规模验证盈利模型,再在盈利的基础上复制、扩张。互联网企业可以跳过盈利模型,而以用户或顾客增长模型来作为发展逻辑,先圈占用户或顾客到定规模,然后在海量用户基础上,用规模优势或商业模式创新来实现盈利。 营销和运营效能不同 借助这些—手且精准的咖啡数据,咖啡零售行业普遍面临的供应链、店面选址、复购率等难题,有可能获得高精度的解决方案 这些用户行为互联网数据可以记录和储存,进行用户的数据分析,实现用户的消费行为画像 基于现有用户的流量,瑞幸咖啡能够打造“流量池”,凭借流量池运营,不断带来新的用户裂变,低成本实现顾客增长 扩张之路 不断烧钱 不断发放低价优惠券 不断请大明星代言 一次又一次地拉高了营销收入 带来的影响 瑞幸咖啡股价下跌导致连环爆仓 瑞幸牵连了中概股，投资机构信心下降，美国出台更严格策略 造假谁获得了好处？ 大多数人都没套现，陆正耀不仅没赚到钱，而且用股权质押借了很多钱 少数投资机构套现了 启示 增加造假成本 容易被发现 惩罚不可承受之重 一个企业、一个人造假，会影响背后的机构甚至地域的声誉。 做人，诚信为本。 Q&A 中国机构为什么没有做空报告 中国没有做空机制，股票下跌没有人赚钱 一般遇到烂公司都不会写报告 花钱摆平，防止报告的发布 中国散户很多，股票搞起来很难，搞死很容易，允许做空会使得市场混乱 为什么一开始没有发现 一开始数量少，还可以掩盖，后来数量太大了，就不可以 完全依赖审计不行，但审计是一个很好的机制 瑞兴造假的动机是否有可能是互联网泡沫破裂导致的投资方撤资压力,或者管理层内部的业绩压力? 瑞幸不是互联网企业，也不存在泡沫 为什么自爆： 窟窿太大了，盖不住了 疫情下经济不景气，买咖啡业绩严重下滑 鸣谢 Rui Lu(SYSU) Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 22:35:23 "},"Course_study/International_Finance/":{"url":"Course_study/International_Finance/","title":"International_Finance","keywords":"","body":"国际经济学=国际金融+国际贸易 国际金融=开放的宏观经济学 国际贸易=开放的微观经济学 国际金融:国际货币经济学或国际财务管理。国际金融学(前者)是以国际货币关系为研究对象,解释全球范围资金运动的现象与内在规律,探求开放经济条件下实现内外均衡的宏观经济政策的一门独立学科二战后建立的布雷顿森林体系取代了国际金本位制 国际金融问题开始其独立的特点。20世纪60年代前后,国际金融学研究开始独立发展。布雷顿森林体系( Bretton Woods system)崩溃后的国际金融领域发生巨大的变化。 Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-21 16:11:12 "},"Course_study/International_Finance/Exchanges.html":{"url":"Course_study/International_Finance/Exchanges.html","title":"Exchanges","keywords":"","body":"外汇的概念 外汇：国际汇兑（Foreign Exchange）的简称；外国货币或以外国货币表示的资产，可清偿国际债务。 动态：国际汇兑、国际结算（银行） 静态： 广义：外币资产或债权 狭义：以外币表示的、可直接用于国际结算的支付手段 外汇的种类 按是否可自由兑换 自由外汇( Free Convertible Exchange)(可兑换货币Convertible Currency):目前世界上有五十多种货币是可兑换货币,如美元、英镑、日元、瑞士法郎等。 记账外汇(协定或清算):未经货币发行国批准不能自由兑换成其他货币或对第三国进行支付。 按外汇来源: 贸易外汇:货物出口取得的外汇 非贸易外汇:对外提供劳务(运输、保险、旅游等)、汇回投资收益(利息、股息、利润等)和侨汇等。 按外汇交易的交割日期: 即期外汇:现汇,指在买卖成交后的两个营业日内办理交割手续的外汇。 远期外汇:期汇,指买卖的双方先按商定的汇率和数量签订买卖合同,约定到将来(如30、60、90天等)办理交割。 汇率的标价法 汇率:货币之间的兑换比率 标价法( exchange Quotation) 直接标价法(应付标价法):单位外币的本币价格(绝大多数国家:人民币、日元、瑞士法郎、加元)。 间接标价法(应收标价法):单位本币的外币价格(英镑、美元、欧元、澳元)。 美元标价法(国际外汇市场通行,除英镑、欧元、澳元外):单位美元的各国货币价格。 基准货币(单位)与标价货币 国家或地区 中国 人民币元 RMB￥ CNY 香港 港元 HKS HKD 美国 美元 $ USD 日本 日元 ￥ JPY 欧元区 欧元 € EUR 瑞士 瑞士法郎 SF CHF 英国 英镑 £ GBP 汇率的种类 按制定汇率的方法 基本汇率：本币与关键货币之间的汇率。 套算汇率(交叉汇率)：交叉汇率 根据基本汇率，参考主要外汇市场行情推算本国货币与非关键货之间的汇率。 西方外汇银行报价时采用美元标价法，为换算出各种货币间的汇率，须通过各种货币对美元的汇率进行套算。 按银行买卖外汇角度 买入汇率( Buying rate, the Bid Rate)：银行从同业或客户买入外汇时使用的汇率。 卖出汇率( Selling Rate, the offer/ask rate)：即银行向同业或客户卖出外汇时使用的汇率。 中间汇率：银行买入价和银行卖出价的算术平均数。中间汇率主要用于新闻报道和经济分析。 现钞汇率 现钞汇率：银行买卖外国钞票的价格。 通常：现钞卖出价>现汇卖出价>现汇买入价>现钞买入价 现汇买入价>现钞买入价 外币现钞不能在交易当地流通使用，得等现钞积累到一定数量，银行才把这些外国现钞运送到发行国银行存储并获得利息。保管费、运输费、保险费，且有时滞利息损失。 按外汇的汇付方式 电汇汇率：是银行以电汇（电报）方式买卖外汇时使用的汇率。外汇市场上普遍公布的汇率。 信汇汇率：银行以信汇（信函通知办理）方式买卖外汇时所使用的汇率。 电汇汇率>信汇汇率（买入和卖出） 信汇需要一段时间才能到达对方手中，这一段时间里，钱还在银行里，银行可以吃利息 票汇汇率：是银行以汇票方式（自带或邮寄）买卖外汇时使用的汇率。 电汇汇率>票汇汇率 延迟一段时间收到，银行可以吃一部分利息 我国银行的做法:不同于国际惯例!电汇、信汇票汇卖出采用同一汇率。但在买入外币票汇,旅行支票时,因要垫付人民币资金,银行却要收取一家的贴息。 按外汇交易交割日不同 即期汇率（现汇汇率）：买卖双方成交后，在两个营业日（Working Day）以内办理交割（Delivery）使用的汇率。 远期汇率（期汇汇率）：买卖双方成交时，约定在未来某一时间进行交割使用的汇率。 期汇的买卖差价>现汇买卖差价 买卖价差的分解（金融市场微观结构）：逆向选择成本、存货成本、指令处理成本。 报价方式 即期汇率 银行一般都直接报出即期汇率。 远期汇率 直接报价（Outright Rate） 与现汇报价相同，直接报出不同交割期限期汇的买入价和卖出价（日本、瑞士等）。可是直接标价法或间接标价法。 远期差价（Forward Margin） 掉期率（Swap Rate）报价：报出期汇汇率偏离即期汇率的值或点数，即升水或贴水幅度（英、美、德、法等）。 远期差价的三种形式 升水（at premium）：表示期汇比现汇贵 贴水（at discount）：表示期汇比现汇便宜 平价（at par）：表示两者相等 银行报出的远期差价在实务中常用点数表示，每点（point）为万分之一，即0.0001 直接标价法：远期汇率=即期汇率+升水（-贴水） 间接标价法：远期汇率=即期汇率-升水（+贴水） 实际外汇交易中，也报出了远期外汇的买入价和卖出价。远期差价的升水值或贴水值也有一高一低两个数字。 在直接标价法下，如远期外汇为升水，则报出的远期差价形如“左低右高” ；如远期外汇为贴水，则报出的远期差价形如“左高右低” 。 在间接标价法下，如远期外汇为升水，则报出的远期差价形如“左高右低” ；如远期外汇为贴水，则报出的远期差价形如“左低右高” 。 按照汇率制度角度 固定汇率、浮动汇率。法定升值与升值、法定贬值与贬值 Revaluation- Appreciation; Devaluation-Depreciation 按对外江管理的宽严分 官方汇率和市场汇率 名义汇率、实际汇率和有效汇率汇率的其他划分方式 名义汇率：现实中的货币兑换比率。它可能由市场决定，也可能由官方制定。 实际汇率（Real Exchange Rate）：名义汇率用两国价格水平调整后的汇率。即外国商品的本国商品相对价格，反映了本国商品的国际竞争力。名义汇率R与实际汇率e之间的关系是： Nominal exchange rate=Nominal exchange rate×Foreign currency priceNational currency priceR=e×PfP \\begin{aligned} &&\\mathrm{Nominal \\ exchange \\ rate}&=&\\mathrm{Nominal \\ exchange \\ rate}\\times\\frac{\\mathrm{Foreign \\ currency \\ price}}{\\mathrm{National \\ currency \\ price}} \\\\ &&\\quad R&=&e\\times\\frac{P_f}{P} \\end{aligned} ​​​​​​​​​Nominal exchange rate​R​​​=​=​​​Nominal exchange rate×​National currency price​​Foreign currency price​​​e×​P​​P​f​​​​​​ 大额指令含有更多信息 收到大多数关注的股票私有信息少 Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-21 16:49:41 "},"Course_study/Random_process/":{"url":"Course_study/Random_process/","title":"Random_process","keywords":"","body":"参考教材 中文 林文烈，应用随机过程，清华大学出版社 以往历年笔记 英文 Lecture on Stochastic Process, Columbia University 评分 平时30%，期末50%，两次测验分别10% Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-21 21:42:31 "},"Course_study/Random_process/Basics.html":{"url":"Course_study/Random_process/Basics.html","title":"Basics","keywords":"","body":"概率空间 Ω\\OmegaΩ：样本空间 事件、样本点ω∈Ω\\omega \\in \\Omegaω∈Ω Ω={ω1,ω2}\\Omega=\\{\\omega_1,\\omega_2\\}Ω={ω​1​​,ω​2​​} 无序 可数或者不可数 ω∈A⊆Ω\\omega\\in A\\subseteq\\Omegaω∈A⊆Ω$$ Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-21 15:55:40 "},"Course_study/Financial_Statement_Analysis/":{"url":"Course_study/Financial_Statement_Analysis/","title":"Financial_Statement_Analysis","keywords":"","body":"财务报表分析 become a 研究员 Protected by CC0-1.0 © Jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-21 22:19:03 "}}