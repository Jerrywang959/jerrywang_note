{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 这是jerrywang的云笔记，主要用于个人整理知识和复习，很多东西都是直接在网上直接copy过来的，若有侵权，请联系w767729940@gmail.com删除。 为什么用gitbook 记笔记的目的本身就是在有需要时检索，放在公网上易于访问，也有可能帮助到有需要的人。 通过gitbook撰写的非数据库markdown文档，更加具有掌控感。 web应用易于扩展和移动，且服务器在国外可以无备案使用域名。 相关链接 个人博客 此笔记的github page托管页面 此笔记的gitbook托管页面 Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-19 17:34:24 "},"Regular_Expression.html":{"url":"Regular_Expression.html","title":"Regular Expression","summary":"正则表达式的学习笔记","keywords":"","body":"Regular Expression 定义 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 基本结构 限定符 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo 能匹配 \"z\" 以及 \"zoo\"。 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 、 \"does\" 中的 \"does\" 、 \"doxy\" 中的 \"do\" 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 {n,m} m 和 n 均为非负整数，其中n 最少匹配 n 次且最多匹配 m 次。例如，\"o{1,3}\" 将匹配 \"fooooood\" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 特殊字符 特殊字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\\n' 或 '\\r'。要匹配 $ 字符本身，请使用 \\$。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\(。 * 匹配前面的子表达式零次或多次。要匹配 字符，请使用 `\\`。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 \\[。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\\n' 匹配换行符。序列 '\\\\' 匹配 \"\\\"，而 '\\(' 则匹配 \"(\"。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \\^。 { 标记限定符表达式的开始。要匹配 {，请使用 \\{。 | 指明两项之间的一个选择。要匹配 |，请使用 \\|。 非打印字符 字符 描述 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 定位符 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。 举例 匹配所有正整数，不包括0 [1-9][0-9]* 匹配1~99 [1-9][0-9]? 匹配章节 ^Chapter [1-9][0-9]{0,1}$ 匹配Chapter中的apt，但不匹配aptitude中的apt \\Bapt 贪婪匹配与非贪婪匹配 *、+ 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 RUNOOB-菜鸟教程 匹配RUNOOB-菜鸟教程 而匹配 还不懂的 非捕获元 缓存 反向选择 参考文献 菜鸟教程：正则表达式 - 语法 Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 17:06:49 "},"julia_study/":{"url":"julia_study/","title":"README","summary":"Julia_study group的介绍","keywords":"","body":"Introduction 这一group是jerrywang的julia学习笔记 为什么选择Julia 他真的很好：快、学起来没那么难 专为科学计算而生，甚至对标金融，跟我的方向有些相符 我并不精通任何一门语言，机会成本很低，刚开始学习，希望学习一门有发展潜力的语言。 Julia环境 系统环境 Pkg环境 (@v1.4) pkg> st Status `~/.julia/environments/v1.4/Project.toml` [c52e3926] Atom v0.12.10 [fbb218c0] BSON v0.2.5 [6e4b80f9] BenchmarkTools v0.5.0 [ad839575] Blink v0.12.3 [336ed68f] CSV v0.6.1 [3895d2a7] CUDAapi v4.0.0 [c5f51814] CUDAdrv v6.2.2 [be33ccc6] CUDAnative v3.0.4 [5ae59095] Colors v0.12.0 [3a865a2d] CuArrays v2.0.1 [5789e2e9] FileIO v1.2.4 [587475ba] Flux v0.10.4 [0c68f7d7] GPUArrays v3.1.0 [7073ff75] IJulia v1.21.2 [916415d5] Images v0.22.2 [e5e0dc1b] Juno v0.8.1 [eb30cadb] MLDatasets v0.5.1 [47be7bcc] ORCA v0.3.1 [d96e819e] Parameters v0.12.0 [f0f68f2c] PlotlyJS v0.13.1 [91a5bcdd] Plots v1.0.11 [438e738f] PyCall v1.91.4 [1d978283] TensorFlow v0.11.0 [b8865327] UnicodePlots v1.1.0 [0f1e0344] WebIO v0.8.13 [de0858da] Printf [9a3f8284] Random [10745b16] Statistics 参考资料 在这里列出该group下的所有参考资料 官方文档 Flux官方文档 WebIO官方文档 教学视频 Julia acadamy 论坛交流 Plots绘图中乱码 Github Issue Error with unicode labels in GR backend 百科 维基百科-LU分解 维基百科-QR分解 Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-19 11:53:13 "},"julia_study/Base/":{"url":"julia_study/Base/","title":"Base","keywords":"","body":"Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 02:21:50 "},"julia_study/Base/Basic_gammer.html":{"url":"julia_study/Base/Basic_gammer.html","title":"Basic_gammer","summary":"基本命令","keywords":"","body":"Basic Gammer 多行注释 #= This is a multi-line comment 这是多行注释 =# 基本运算符号 余数% julia> 10 % 3 1 julia> 25%4 1 语句连接符号 && 意思是 \"和\" Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 02:21:50 "},"julia_study/Base/String.html":{"url":"julia_study/Base/String.html","title":"String","summary":"Julia中对于字符串的操作","keywords":"","body":"String 生成字符串 julia> a=\"hello, world\" \"hello, world\" 多行字符串 并且可以包含字符串内的双引号 julia> a=\"\"\" hello, world, I am julia \"\"\" \" hello,\\nworld,\\nI am julia \" 字符串内使用变量的实际数值 用$ julia> name = \"Jane\" \"Jane\" julia> println(\"Hello, my name is $name.\") Hello, my name is Jane. 合并字符串 julia> s3 = \"How many cats \"; julia> s4 = \"is too many cats?\"; julia> string(s3, s4) \"How many cats is too many cats?\" julia> s3*s4 \"How many cats is too many cats?\" julia> \"$s3$s4\" \"How many cats is too many cats?\" Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 02:21:50 "},"julia_study/Base/DataStructure.html":{"url":"julia_study/Base/DataStructure.html","title":"DataStructure","summary":"Julia的数据结构","keywords":"","body":"DataStructure Tuples 创建元组 (item1, item2, ...) julia> myfavoriteanimals = (\"penguins\", \"cats\", \"sugargliders\") (\"penguins\", \"cats\", \"sugargliders\") 索引元组 julia是从1开始索引 julia> myfavoriteanimals[1] \"penguins\" 不能改变元组 因为它是immutable的 julia> myfavoriteanimals[1] = \"otters\" ERROR: MethodError: no method matching setindex!(::Tuple{String,String,String}, ::String, ::Int64) Stacktrace: [1] top-level scope at REPL[10]:1 NamedTuples 和一般的元组一样，只是把元组内部的每个元素都有一个name，用数字或者.name索引 (name1 = item1, name2 = item2, ...) julia> myfavoriteanimals = (bird = \"penguins\", mammal = \"cats\", marsupial = \"sugargliders\") (bird = \"penguins\", mammal = \"cats\", marsupial = \"sugargliders\") julia> myfavoriteanimals[1] \"penguins\" julia> myfavoriteanimals.bird \"penguins\" Dictionary 创建字典 Dict(key1 => value1, key2 => value2, ...)，字典的值需是相同的类型 julia> myphonebook = Dict(\"Jenny\" => \"867-5309\", \"Ghostbusters\" => \"555-2368\") Dict{String,String} with 2 entries: \"Jenny\" => \"867-5309\" \"Ghostbusters\" => \"555-2368\" 读取字典内容 julia> myphonebook[\"Jenny\"] \"867-5309\" 增加字典内容 julia> myphonebook[\"Kramer\"]=\"555-FILK\" \"555-FILK\" julia> myphonebook Dict{String,String} with 3 entries: \"Jenny\" => \"867-5309\" \"Kramer\" => \"555-FILK\" \"Ghostbusters\" => \"555-2368\" 删除一个键值对应并返回值 使用pop! julia> pop!(myphonebook, \"Kramer\") \"555-FILK\" julia> myphonebook Dict{String,String} with 2 entries: \"Jenny\" => \"867-5309\" \"Ghostbusters\" => \"555-2368\" Arrays 与Tuples不同，Arrays是可变的；与Dictionary不同，Arrays是有序的 [item1, item2, ...] 创建Arrays 返回的类型中，第一个“String”表示Arrays内元素的类型，1表示Arrays的维度 julia> myfriends = [\"Ted\", \"Robyn\", \"Barney\", \"Lily\", \"Marshall\"] 5-element Array{String,1}: \"Ted\" \"Robyn\" \"Barney\" \"Lily\" \"Marshall\" julia> fibonacci = [1, 1, 2, 3, 5, 8, 13] 7-element Array{Int64,1}: 1 1 2 3 5 8 13 julia> mixture = [1, 1, 2, 3, \"Ted\", \"Robyn\"] 6-element Array{Any,1}: 1 1 2 3 \"Ted\" \"Robyn\" 索引Arrays 用数字所在的序号索引 julia> myfriends[3] \"Barney\" 修改Arrays某一索引 julia> myfriends[3] = \"Baby Bop\" \"Baby Bop\" 增加和减少Arrays push!,pop! julia> push!(fibonacci, 21) 8-element Array{Int64,1}: 1 1 2 3 5 8 13 21 julia> pop!(fibonacci) 21 julia> fibonacci 7-element Array{Int64,1}: 1 1 2 3 5 8 13 复杂的Arrays 可以是多个维度的Arrays，也可以是Arrays的Arrays julia> favorites = [[\"koobideh\", \"chocolate\", \"eggs\"],[\"penguins\", \"cats\", \"sugargliders\"]] 2-element Array{Array{String,1},1}: [\"koobideh\", \"chocolate\", \"eggs\"] [\"penguins\", \"cats\", \"sugargliders\"] julia> numbers = [[1, 2, 3], [4, 5], [6, 7, 8, 9]] 3-element Array{Array{Int64,1},1}: [1, 2, 3] [4, 5] [6, 7, 8, 9] julia> rand(4, 3) 4×3 Array{Float64,2}: 0.580342 0.840483 0.590226 0.612861 0.801844 0.859797 0.742443 0.590106 0.649077 0.477118 0.72509 0.342509 julia> rand(4, 3, 2) 4×3×2 Array{Float64,3}: [:, :, 1] = 0.888219 0.384393 0.0619398 0.473101 0.204024 0.784434 0.72608 0.92305 0.100044 0.815554 0.161155 0.416701 [:, :, 2] = 0.305238 0.530652 0.74287 0.484455 0.0904463 0.105327 0.0632765 0.818537 0.704337 0.152749 0.0189906 0.120929 创建副本防止绑定更新 使用=生产的新Arrays，内存地址上和原来的Arrays是相同的，因此会同时更新 julia> fibonacci 7-element Array{Int64,1}: 1 1 2 3 5 8 13 julia> somenumbers = fibonacci 7-element Array{Int64,1}: 1 1 2 3 5 8 13 julia> somenumbers[1] = 404 404 julia> fibonacci 7-element Array{Int64,1}: 404 1 2 3 5 8 13 若要防止此情况，使用copy创建新的Arrays julia> fibonacci 7-element Array{Int64,1}: 1 1 2 3 5 8 13 julia> somemorenumbers = copy(fibonacci) 7-element Array{Int64,1}: 1 1 2 3 5 8 13 julia> somemorenumbers[1] = 404 404 julia> fibonacci 7-element Array{Int64,1}: 1 1 2 3 5 8 13 Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 02:21:50 "},"julia_study/Base/Control_flow.html":{"url":"julia_study/Base/Control_flow.html","title":"Control_flow","summary":"Julia控制句法","keywords":"","body":"Control flow While循环语句 while *condition* *loop body* end 举例 while n 1 2 3 4 5 6 7 8 9 10 10 myfriends = [\"Ted\", \"Robyn\", \"Barney\", \"Lily\", \"Marshall\"] i = 1 while i Hi Ted, it's great to see you! Hi Robyn, it's great to see you! Hi Barney, it's great to see you! Hi Lily, it's great to see you! Hi Marshall, it's great to see you! For循环语句 for *var* in *loop iterable* *loop body* end 举例 myfriends = [\"Ted\", \"Robyn\", \"Barney\", \"Lily\", \"Marshall\"] for friend in myfriends println(\"Hi $friend, it's great to see you!\") end >Hi Ted, it's great to see you! Hi Robyn, it's great to see you! Hi Barney, it's great to see you! Hi Lily, it's great to see you! Hi Marshall, it's great to see you! m, n = 5, 5 A = fill(0, (m, n)) >5×5 Array{Int64,2}: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 for i in 1:m for j in 1:n A[i, j] = i + j end end A >5×5 Array{Int64,2}: 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 5 6 7 8 9 6 7 8 9 10 for语句的其他形式 B = fill(0, (m, n)) >5×5 Array{Int64,2}: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 for i in 1:m, j in 1:n B[i, j] = i + j end B >5×5 Array{Int64,2}: 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 5 6 7 8 9 6 7 8 9 10 C = [i + j for i in 1:m, j in 1:n] >5×5 Array{Int64,2}: 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 5 6 7 8 9 6 7 8 9 10 If条件语句 if *condition 1* *option 1* elseif *condition 2* *option 2* else *option 3* end 举例 julia> N =4 4 julia> if (N % 3 == 0) && (N % 5 == 0) # `&&` means \"AND\"; % computes the remainder after division println(\"FizzBuzz\") elseif N % 3 == 0 println(\"Fizz\") elseif N % 5 == 0 println(\"Buzz\") else println(N) end 4 if语句的其他形式 三元运算符 a ? b : c 这等同于 if a b else c end 使用语句连接符 julia> x=3 3 julia> (x > 0) && error(\"x cannot be greater than 0\") ERROR: x cannot be greater than 0 Stacktrace: [1] error(::String) at ./error.jl:33 [2] top-level scope at REPL[8]:1 julia> x=-4 -4 julia> (x > 0) && error(\"x cannot be greater than 0\") false julia> true || println(\"hi\") true julia> false || println(\"hi\") hi Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 02:21:50 "},"julia_study/Base/Functions.html":{"url":"julia_study/Base/Functions.html","title":"Functions","summary":"函数的基本用法","keywords":"","body":"Functions Declare a function 标准形式 用 fuction … end 声明一个函数 julia> function sayhi(name) println(\"Hi $name, it's great to see you!\") end sayhi (generic function with 1 method) julia> sayhi(\"C-3PO\") Hi C-3PO, it's great to see you! 简介形式 julia> sayhi2(name) = println(\"Hi $name, it's great to see you!\") sayhi2 (generic function with 1 method) julia> sayhi2(\"R2D2\") Hi R2D2, it's great to see you! 匿名函数形式 julia> sayhi3 = name -> println(\"Hi $name, it's great to see you!\") #3 (generic function with 1 method) julia> sayhi3(\"Chewbacca\") Hi Chewbacca, it's great to see you! Duck-typing If it walks like a duck and it quacks like a duck, then it must be a duck 函数方法不依赖于对象的类型，其他类型的对象会尽可能地调用方法，若能调用成功，则函数对于此类型的对象可用。julia的函数即是这样的。 julia> function sayhi(name) println(\"Hi $name, it's great to see you!\") end sayhi (generic function with 1 method) julia> sayhi(55595472) Hi 55595472, it's great to see you! julia> f(x)=x^2 f (generic function with 1 method) julia> f(\"hi\") \"hihi\" julia> f(rand(3,3)) 3×3 Array{Float64,2}: 0.738116 0.982017 0.529161 0.339603 0.528315 0.473647 0.494267 0.500296 0.365849 julia> f(rand(3)) ERROR: MethodError: no method matching ^(::Array{Float64,1}, ::Int64) Closest candidates are: ^(::Float16, ::Integer) at math.jl:885 ^(::Regex, ::Integer) at regex.jl:712 ^(::Missing, ::Integer) at missing.jl:155 ... Stacktrace: [1] macro expansion at ./none:0 [inlined] [2] literal_pow at ./none:0 [inlined] [3] f(::Array{Float64,1}) at ./REPL[4]:1 [4] top-level scope at REPL[7]:1 Mutating vs. non-mutating functions 带!的函数会改变输入的参数，不带!的函数不会改变输入的参数 julia> v = [3, 5, 2] 3-element Array{Int64,1}: 3 5 2 julia> sort(v);v 3-element Array{Int64,1}: 3 5 2 julia> sort!(v);v 3-element Array{Int64,1}: 2 3 5 higher order functions 高阶函数 map 把一个函数分别传递到一个数据结构中的每一个数，并映射到函数值 map(f, [1, 2, 3])将得到[f(1), f(2), f(3)] julia> map(x -> x^3, [1, 2, 3]) 3-element Array{Int64,1}: 1 8 27 broadcast broadcast(f, [1, 2, 3])将得到f.([1, 2, 3]) julia> f(x)=x^2 f (generic function with 1 method) julia> A = [i + 3*j for j in 0:2, i in 1:3] 3×3 Array{Int64,2}: 1 2 3 4 5 6 7 8 9 julia> A .+ 2 .* f.(A) ./ A 3×3 Array{Float64,2}: 3.0 6.0 9.0 12.0 15.0 18.0 21.0 24.0 27.0 julia> broadcast(x -> x + 2 * f(x) / x, A) 3×3 Array{Float64,2}: 3.0 6.0 9.0 12.0 15.0 18.0 21.0 24.0 27.0 Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 23:50:11 "},"julia_study/Base/Packages.html":{"url":"julia_study/Base/Packages.html","title":"Package","summary":"Julia pkg的使用和管理","keywords":"","body":"Packages julia有专门的包管理工具——Pkg，可以用 ]进入pkg管理页面，也可以使用using Pkg Pkg.xxx来管理Pkg (@v1.4) pkg> add Colors Updating registry at `~/.julia/registries/General` Updating git-repo `https://github.com/JuliaRegistries/General.git` Resolving package versions... Updating `~/.julia/environments/v1.4/Project.toml` [no changes] Updating `~/.julia/environments/v1.4/Manifest.toml` [no changes] julia> using Colors julia> palette = distinguishable_colors(100) 100-element Array{RGB{N0f8},1} with eltype RGB{FixedPointNumbers.Normed{UInt8,8}}: RGB{N0f8}(0.0,0.0,0.0) RGB{N0f8}(1.0,1.0,0.455) RGB{N0f8}(1.0,0.608,1.0) RGB{N0f8}(0.0,0.827,1.0) RGB{N0f8}(0.886,0.388,0.051) RGB{N0f8}(0.0,0.494,0.0) RGB{N0f8}(0.0,0.314,0.902) RGB{N0f8}(0.675,0.0,0.278) ⋮ RGB{N0f8}(0.855,0.0,0.247) RGB{N0f8}(0.18,0.129,0.141) RGB{N0f8}(0.0,0.345,0.082) RGB{N0f8}(1.0,0.557,0.114) RGB{N0f8}(0.4,0.455,0.694) RGB{N0f8}(0.0,0.804,0.678) RGB{N0f8}(0.0,0.498,0.388) RGB{N0f8}(0.6,0.435,0.239) julia> rand(palette, 3, 3) 3×3 Array{RGB{N0f8},2} with eltype RGB{FixedPointNumbers.Normed{UInt8,8}}: RGB{N0f8}(0.196,0.212,0.024) … RGB{N0f8}(0.62,0.62,0.467) RGB{N0f8}(0.0,0.498,0.388) RGB{N0f8}(0.655,0.525,0.0) RGB{N0f8}(0.306,0.427,0.314) RGB{N0f8}(1.0,0.306,0.78) RGB的向量在nteract中输出会自动渲染成颜色，而在repl不会。 Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 10:11:32 "},"julia_study/Base/Plotting.html":{"url":"julia_study/Base/Plotting.html","title":"Plotting","summary":"Julia 的画图方法","keywords":"","body":"Plotting Plots 使用“Plots”这一Packages画图，Plots本质上也只是一个前端的工具，真正渲染制作出图片的其实是后端的一些程序。 后端程序 GR 输入以下的命令使用GR作为后端 julia> using Plots julia> gr() Plots.GRBackend() julia> plot(rand(10)) 但GR对中文的图像标注并不友好，我在deepin linux 15.11上无法解决这一问题，因此选择了其他的后端 PlotlyJS 这一后端支持中文输入，需要额外安装PlotlyJS、WebIO和ORCA 安装和配置 ]add PlotlyJS ORCA WebIO 若从repl中画图，会自动弹出jupyter的Blink窗口，不需要配置WebIO。 若从jupyter中画图，则需要安装对应的插件 using WebIO WebIO.install_jupyter_nbextension() jupyterlab则使用以下的命令 using WebIO WebIO.install_jupyter_nbextension() 以上命令最好在repl中进行，并杀死jupyter进程 nteract(0.22.4)貌似还未适配WebIO.jl，但安装jupyter 的插件后，不影响画图结果。 使用PlotlyJS 使用如下命令把plotlyjs作为plots的后端 using Plots plotlyjs() 这会一些warning，不知道为什么，但不影响画图结果 举例 UnicodePlots 安装 ] add UnicodePlots 使用 unicodeplots() 画出来效果如下 unicodeplots() p1 = plot(x, x.^2) title!(\"你好\") 这样的粗略的画图便于在命令行中展示，而且支持中文。 画图命令 plot 折线图 using Plots plotlyjs() x = [14.4, 14.5, 14.8, 15.2, 15.5, 15.8]; y = [45000, 20000, 15000, 5000, 400, 17]; plot(x,y,title=\"test\") scatter 散点图 using Plots plotlyjs() x = [14.4, 14.5, 14.8, 15.2, 15.5, 15.8]; y = [45000, 20000, 15000, 5000, 400, 17]; scatter(x, y, label=\"points\") using Plots plotlyjs() x = [14.4, 14.5, 14.8, 15.2, 15.5, 15.8]; y = [45000, 20000, 15000, 5000, 400, 17]; plot(x,y,title=\"test\") scatter!(x, y, label=\"points\") 后面的!表示在原图的基础上继续画图，而非生成一个新的图像 一些参数 参数可以直接在plot函数的内部加上，也可以在画图之后以!函数的形式加上 using Plots plotlyjs() x = [14.4, 14.5, 14.8, 15.2, 15.5, 15.8]; y = [45000, 20000, 15000, 5000, 400, 17]; plot(x,y,xlabel=\"这是x轴\",ylabel=\"这是y轴\",title=\"这是标题\") using Plots plotlyjs() x = [14.4, 14.5, 14.8, 15.2, 15.5, 15.8]; y = [45000, 20000, 15000, 5000, 400, 17]; plot(x,y) xlabel!(\"这是x轴\") ylabel!(\"这是y轴\") title!(\"这是标题1\") xflip! xflip!()翻转x轴，yflip!()反转y轴 多个子图 用一个变量表示一个子图，最后用plot连接起来 using Plots x=1:10 plotlyjs() p1 = plot(x, x.+1) p2 = plot(x, x.^2) p3 = plot(x, x.^3) p4 = plot(x, x.^4) plot(p1, p2, p3, p4, layout = (2, 2)) Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 20:28:15 "},"julia_study/Base/Multiple_Dispatch.html":{"url":"julia_study/Base/Multiple_Dispatch.html","title":"Multiple_Dispatch","keywords":"","body":"Multiple Dispatch Multiple Dispatch是和duck-type相对应的，多重分派即是对于同名函数，不同的变量类型给予不同的方法 Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-19 20:01:45 "},"julia_study/Base/Factorizations.html":{"url":"julia_study/Base/Factorizations.html","title":"Factorizations","summary":"Julia因式分解函数","keywords":"","body":"Factorizations 因式分解相关函数，出现了一些我并不能看懂的线性代数方法。 LU factorizations 在线性代数与数值分析中，LU分解是矩阵分解的一种，将一个矩阵分解为一个下三角矩阵和一个上三角矩阵的乘积，有时需要再乘上一个置换矩阵。LU分解可以被视为高斯消元法的矩阵形式。在数值计算上，LU分解经常被用来解线性方程组、且在求反矩阵和计算行列式中都是一个关键的步骤。 PA=LU PA = LU PA=LU AAA 是被分解的矩阵，PPP 是置换矩阵，LLL 是下三角矩阵，UUU是上三角矩阵。 使用函数lu()进行LU分解，using lufact. julia> A = rand(3, 3) 3×3 Array{Float64,2}: 0.111894 0.730218 0.283805 0.66003 0.487591 0.945071 0.644679 0.0101276 0.862639 julia> using LinearAlgebra julia> Alu = lu(A) LU{Float64,Array{Float64,2}} L factor: 3×3 Array{Float64,2}: 1.0 0.0 0.0 0.169529 1.0 0.0 0.976742 -0.719817 1.0 U factor: 3×3 Array{Float64,2}: 0.66003 0.487591 0.945071 0.0 0.647557 0.123588 0.0 0.0 0.0285094 使用.P,.L,.U调用分解后的P矩阵,L矩阵或U矩阵 julia> Alu.P 3×3 Array{Float64,2}: 0.0 1.0 0.0 1.0 0.0 0.0 0.0 0.0 1.0 julia> Alu.L 3×3 Array{Float64,2}: 1.0 0.0 0.0 0.169529 1.0 0.0 0.976742 -0.719817 1.0 julia> Alu.U 3×3 Array{Float64,2}: 0.66003 0.487591 0.945071 0.0 0.647557 0.123588 0.0 0.0 0.0285094 Julia的多重分派可以使得对一个被分解后的矩阵整体进行某些操作，并得到相同结果。以下例子包括了矩阵“除法”和求行列式 julia> b=rand(3) 3-element Array{Float64,1}: 0.7071667357222131 0.14187417923162382 0.8633724393268927 julia> A\\b 3-element Array{Float64,1}: -55.646676986062815 -7.08892173833099 42.67067045131066 julia> Alu\\b 3-element Array{Float64,1}: -55.646676986062815 -7.08892173833099 42.67067045131066 julia> det(A) ≈ det(Alu) true QR factorizations QR分解法是三种将矩阵分解的方式之一。这种方式，把矩阵分解成一个正交矩阵与一个上三角矩阵的积。QR分解经常用来解线性最小二乘法问题。QR分解也是特定特征值算法即QR算法的基础。 A=QR A=QR A=QR AAA 为被分解的矩阵，QQQ是正交矩阵，RRR是上三角矩阵 使用qr()对矩阵进行QR分解操作，using qrfact julia> using LinearAlgebra julia> Aqr = qr(A) LinearAlgebra.QRCompactWY{Float64,Array{Float64,2}} Q factor: 3×3 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}: -0.120395 0.891848 0.436018 -0.710173 0.229519 -0.665563 -0.693656 -0.389779 0.605734 R factor: 3×3 Array{Float64,2}: -0.929392 -0.441214 -1.30371 0.0 0.759207 0.133785 0.0 0.0 0.0172691 使用.Q,.R调用分解后的QQQ矩阵,RRR矩阵 julia> Aqr.Q 3×3 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}: -0.120395 0.891848 0.436018 -0.710173 0.229519 -0.665563 -0.693656 -0.389779 0.605734 julia> Aqr.R 3×3 Array{Float64,2}: -0.929392 -0.441214 -1.30371 0.0 0.759207 0.133785 0.0 0.0 0.0172691 Eigendecompositions 特征分解，奇异值分解，Hessenberg分解和Schur分解的结果are all stored in Factorization types1. 用eigen求解矩阵特征值和特征向量 julia> Asym = A + A' 3×3 Array{Float64,2}: 0.223788 1.39025 0.928484 1.39025 0.975182 0.955199 0.928484 0.955199 1.72528 julia> AsymEig = eigen(Asym) Eigen{Float64,Float64,Array{Float64,2},Array{Float64,1}} values: 3-element Array{Float64,1}: -0.8530493828857049 0.5600188449031531 3.21727866868319 vectors: 3×3 Array{Float64,2}: 0.812969 -0.337866 -0.474266 -0.57692 -0.577869 -0.577262 -0.0790263 0.74291 -0.664711 julia> AsymEig.values 3-element Array{Float64,1}: -0.8530493828857049 0.5600188449031531 3.21727866868319 julia> AsymEig.vectors 3×3 Array{Float64,2}: 0.812969 -0.337866 -0.474266 -0.57692 -0.577869 -0.577262 -0.0790263 0.74291 -0.664711 Once again, when the factorization is stored in a type, we can dispatch on it and write specialized methods that exploit the properties of the factorization, e.g. that A−1=(VΛV−1)−1=VΛ−1V−1 A^{-1}=(V\\Lambda V^{-1})^{-1}=V\\Lambda^{-1}V^{-1}A​−1​​=(VΛV​−1​​)​−1​​=VΛ​−1​​V​−1​​.2 julia> inv(AsymEig)*Asym 3×3 Array{Float64,2}: 1.0 1.66533e-15 -3.88578e-16 -6.66134e-16 1.0 0.0 8.88178e-16 -8.88178e-16 1.0 Special matrix structures 矩阵结构在线性代数中非常重要。要了解它的重要性，让我们使用更大的线性系统 issymmetric检验一个矩阵是否是对称阵，并返回true or false julia> using LinearAlgebra julia> n = 1000; julia> A = randn(n,n); julia> Asym = A + A'; julia> issymmetric(Asym) true julia> Asym_noisy = copy(Asym); julia> Asym_noisy[1,2] += 5eps(); julia> issymmetric(Asym_noisy); false 1. 我不太理解，因此保留英文 ↩ 2. 这句话我也不懂，还是保留了英文 ↩ Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 08:35:34 "},"julia_study/LinearAlgebra/":{"url":"julia_study/LinearAlgebra/","title":"LinearAlgebra","keywords":"","body":"Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 22:05:50 "},"julia_study/LinearAlgebra/Basic.html":{"url":"julia_study/LinearAlgebra/Basic.html","title":"Basic","summary":"最最最基本的线性代数运算","keywords":"","body":"Basic 生成向量或矩阵 julia> A = rand(1:4,3,3) 3×3 Array{Int64,2}: 4 2 4 4 2 3 1 2 2 julia> x = fill(1.0, (3,)) 3-element Array{Float64,1}: 1.0 1.0 1.0 乘和转置 julia> b = A*x 3-element Array{Float64,1}: 10.0 9.0 5.0 julia> A' 3×3 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}: 4 4 1 2 2 2 4 3 2 julia> transpose(A) 3×3 LinearAlgebra.Transpose{Int64,Array{Int64,2}}: 4 4 1 2 2 2 4 3 2 julia> A'A 3×3 Array{Int64,2}: 33 18 30 18 12 18 30 18 29 \\ 从方程 $Ax=b$ 求解x，其中$A$为方阵 julia> A\\b 3-element Array{Float64,1}: 1.0 1.0 1.0 如果/前是一个过度确定的线性系统(least squares solution)(高矩阵)，我们会得到一个最小二乘法的解。 julia> Atall = rand(3, 2) 3×2 Array{Float64,2}: 0.509259 0.199434 0.927561 0.92623 0.0378898 0.165023 julia> Atall\\b 2-element Array{Float64,1}: 17.8463824370428 -6.596395027758899 如果是秩不足的最小二乘问题，则会得到最小范数最小二乘解 julia> v = rand(3) 3-element Array{Float64,1}: 0.5216257841057546 0.5350262816162525 0.6433750280513937 julia> rankdef = hcat(v, v) 3×2 Array{Float64,2}: 0.521626 0.521626 0.535026 0.535026 0.643375 0.643375 julia> rankdef\\b 2-element Array{Float64,1}: 6.813056253069082 6.81305625306908 如果\\前面的是未定的问题(underdetermined solution)(短矩阵) julia> bshort = rand(2) 2-element Array{Float64,1}: 0.8352714299155983 0.8146631376007327 julia> Ashort = rand(2, 3) 2×3 Array{Float64,2}: 0.287498 0.153943 0.231742 0.479411 0.0772732 0.197439 julia> Ashort\\bshort 3-element Array{Float64,1}: 0.7691000398938104 1.434562771848009 1.697210113213556 内积、外积、叉积 内积 julia> v = [1,2,3] 3-element Array{Int64,1}: 1 2 3 julia> v'v 14 叉积 julia> using LinearAlgebra julia> cross_v=cross(v,v) 3-element Array{Int64,1}: 0 0 0 外积 julia> outer_v=reshape(kron(v,v),length(v),length(v)) 3×3 Array{Int64,2}: 1 2 3 2 4 6 3 6 9 Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 23:02:37 "},"julia_study/Flux/":{"url":"julia_study/Flux/","title":"Flux","summary":"Julia Flux Pkg的学习笔记","keywords":"","body":"Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 02:21:50 "},"julia_study/Flux/Functions.html":{"url":"julia_study/Flux/Functions.html","title":"Functions","summary":"Julia Flux Pkg中的函数用法","keywords":"","body":"Fuctions gradient 求导函数，亦称求梯度函数 基本用法 df(x) = gradient(f, x) df为导函数，f为原函数，x为求导变量 gradient(f, [2, 1], [2, 0]) f为原函数，后面两个数组为函数的两个参数向量，该语句返回函数在某一点的导数（梯度） gs=gradient(params(x, y)) do f(x, y) end 通过处理参数集合params来获取导数 params 返回函数参数的函数 update! 按照一定的方式更新网络参数 Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 02:21:50 "},"Course_study/":{"url":"Course_study/","title":"README","summary":null,"keywords":"","body":"Introduction 课程学习笔记 Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 11:49:52 "},"Course_study/DM-ML/":{"url":"Course_study/DM-ML/","title":"DM-ML","summary":null,"keywords":"","body":"Introduction 课程名称：数据挖掘和机器学习 Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 11:52:13 "},"Course_study/DM-ML/Homework.html":{"url":"Course_study/DM-ML/Homework.html","title":"Homework","summary":"作业todo清单","keywords":"","body":"2020-2-20 Read Home Reading 1A: Mathematics for Machine LearningSend the page numbers to ta wherever you can't understand. TA Will collect the information Send a life photo to ta with your namedue day : Apr.23,10pm 发到TA邮箱 Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 15:49:48 "}}