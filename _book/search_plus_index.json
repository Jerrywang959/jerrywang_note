{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 这是jerrywang的云笔记 为什么用gitbook 记笔记的目的本身就是在有需要时检索，放在公网上易于访问，也有可能帮助到有需要的人。 通过gitbook撰写的非数据库markdown文档，更加具有掌控感。 web应用易于扩展和移动，且服务器在国外可以无备案使用域名。 Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 02:21:50 "},"Regular_Expression.html":{"url":"Regular_Expression.html","title":"Regular Expression","summary":"正则表达式的学习笔记","keywords":"","body":"Regular Expression 定义 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 基本结构 限定符 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo 能匹配 \"z\" 以及 \"zoo\"。 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 、 \"does\" 中的 \"does\" 、 \"doxy\" 中的 \"do\" 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 {n,m} m 和 n 均为非负整数，其中n 最少匹配 n 次且最多匹配 m 次。例如，\"o{1,3}\" 将匹配 \"fooooood\" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 特殊字符 特殊字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\\n' 或 '\\r'。要匹配 $ 字符本身，请使用 \\$。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\(。 * 匹配前面的子表达式零次或多次。要匹配 字符，请使用 `\\`。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 \\[。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\\n' 匹配换行符。序列 '\\\\' 匹配 \"\\\"，而 '\\(' 则匹配 \"(\"。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \\^。 { 标记限定符表达式的开始。要匹配 {，请使用 \\{。 | 指明两项之间的一个选择。要匹配 |，请使用 \\|。 非打印字符 字符 描述 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 定位符 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。 举例 匹配所有正整数，不包括0 [1-9][0-9]* 匹配1~99 [1-9][0-9]? 匹配章节 ^Chapter [1-9][0-9]{0,1}$ 匹配Chapter中的apt，但不匹配aptitude中的apt \\Bapt 贪婪匹配与非贪婪匹配 *、+ 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 RUNOOB-菜鸟教程 匹配RUNOOB-菜鸟教程 而匹配 还不懂的 非捕获元 缓存 反向选择 参考文献 菜鸟教程：正则表达式 - 语法 Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 16:52:10 "},"julia_study/":{"url":"julia_study/","title":"README","summary":"Julia_study group的介绍","keywords":"","body":"Readme 这一group是jerrywang的julia学习笔记，在这里列出该group下的所有参考文献 参考文献 Julia acadamy Flux官方文档 Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 02:21:50 "},"julia_study/Base/":{"url":"julia_study/Base/","title":"Base","keywords":"","body":"Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 02:21:50 "},"julia_study/Base/Basic_gammer.html":{"url":"julia_study/Base/Basic_gammer.html","title":"Basic_gammer","summary":"基本命令","keywords":"","body":"Basic Gammer 多行注释 #= This is a multi-line comment 这是多行注释 =# 基本运算符号 余数% julia> 10 % 3 1 julia> 25%4 1 语句连接符号 && 意思是 \"和\" Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 02:21:50 "},"julia_study/Base/String.html":{"url":"julia_study/Base/String.html","title":"String","summary":"Julia中对于字符串的操作","keywords":"","body":"String 生成字符串 julia> a=\"hello, world\" \"hello, world\" 多行字符串 并且可以包含字符串内的双引号 julia> a=\"\"\" hello, world, I am julia \"\"\" \" hello,\\nworld,\\nI am julia \" 字符串内使用变量的实际数值 用$ julia> name = \"Jane\" \"Jane\" julia> println(\"Hello, my name is $name.\") Hello, my name is Jane. 合并字符串 julia> s3 = \"How many cats \"; julia> s4 = \"is too many cats?\"; julia> string(s3, s4) \"How many cats is too many cats?\" julia> s3*s4 \"How many cats is too many cats?\" julia> \"$s3$s4\" \"How many cats is too many cats?\" Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 02:21:50 "},"julia_study/Base/DataStructure.html":{"url":"julia_study/Base/DataStructure.html","title":"DataStructure","summary":"Julia的数据结构","keywords":"","body":"DataStructure Tuples 创建元组 (item1, item2, ...) julia> myfavoriteanimals = (\"penguins\", \"cats\", \"sugargliders\") (\"penguins\", \"cats\", \"sugargliders\") 索引元组 julia是从1开始索引 julia> myfavoriteanimals[1] \"penguins\" 不能改变元组 因为它是immutable的 julia> myfavoriteanimals[1] = \"otters\" ERROR: MethodError: no method matching setindex!(::Tuple{String,String,String}, ::String, ::Int64) Stacktrace: [1] top-level scope at REPL[10]:1 NamedTuples 和一般的元组一样，只是把元组内部的每个元素都有一个name，用数字或者.name索引 (name1 = item1, name2 = item2, ...) julia> myfavoriteanimals = (bird = \"penguins\", mammal = \"cats\", marsupial = \"sugargliders\") (bird = \"penguins\", mammal = \"cats\", marsupial = \"sugargliders\") julia> myfavoriteanimals[1] \"penguins\" julia> myfavoriteanimals.bird \"penguins\" Dictionary 创建字典 Dict(key1 => value1, key2 => value2, ...)，字典的值需是相同的类型 julia> myphonebook = Dict(\"Jenny\" => \"867-5309\", \"Ghostbusters\" => \"555-2368\") Dict{String,String} with 2 entries: \"Jenny\" => \"867-5309\" \"Ghostbusters\" => \"555-2368\" 读取字典内容 julia> myphonebook[\"Jenny\"] \"867-5309\" 增加字典内容 julia> myphonebook[\"Kramer\"]=\"555-FILK\" \"555-FILK\" julia> myphonebook Dict{String,String} with 3 entries: \"Jenny\" => \"867-5309\" \"Kramer\" => \"555-FILK\" \"Ghostbusters\" => \"555-2368\" 删除一个键值对应并返回值 使用pop! julia> pop!(myphonebook, \"Kramer\") \"555-FILK\" julia> myphonebook Dict{String,String} with 2 entries: \"Jenny\" => \"867-5309\" \"Ghostbusters\" => \"555-2368\" Arrays 与Tuples不同，Arrays是可变的；与Dictionary不同，Arrays是有序的 [item1, item2, ...] 创建Arrays 返回的类型中，第一个“String”表示Arrays内元素的类型，1表示Arrays的维度 julia> myfriends = [\"Ted\", \"Robyn\", \"Barney\", \"Lily\", \"Marshall\"] 5-element Array{String,1}: \"Ted\" \"Robyn\" \"Barney\" \"Lily\" \"Marshall\" julia> fibonacci = [1, 1, 2, 3, 5, 8, 13] 7-element Array{Int64,1}: 1 1 2 3 5 8 13 julia> mixture = [1, 1, 2, 3, \"Ted\", \"Robyn\"] 6-element Array{Any,1}: 1 1 2 3 \"Ted\" \"Robyn\" 索引Arrays 用数字所在的序号索引 julia> myfriends[3] \"Barney\" 修改Arrays某一索引 julia> myfriends[3] = \"Baby Bop\" \"Baby Bop\" 增加和减少Arrays push!,pop! julia> push!(fibonacci, 21) 8-element Array{Int64,1}: 1 1 2 3 5 8 13 21 julia> pop!(fibonacci) 21 julia> fibonacci 7-element Array{Int64,1}: 1 1 2 3 5 8 13 复杂的Arrays 可以是多个维度的Arrays，也可以是Arrays的Arrays julia> favorites = [[\"koobideh\", \"chocolate\", \"eggs\"],[\"penguins\", \"cats\", \"sugargliders\"]] 2-element Array{Array{String,1},1}: [\"koobideh\", \"chocolate\", \"eggs\"] [\"penguins\", \"cats\", \"sugargliders\"] julia> numbers = [[1, 2, 3], [4, 5], [6, 7, 8, 9]] 3-element Array{Array{Int64,1},1}: [1, 2, 3] [4, 5] [6, 7, 8, 9] julia> rand(4, 3) 4×3 Array{Float64,2}: 0.580342 0.840483 0.590226 0.612861 0.801844 0.859797 0.742443 0.590106 0.649077 0.477118 0.72509 0.342509 julia> rand(4, 3, 2) 4×3×2 Array{Float64,3}: [:, :, 1] = 0.888219 0.384393 0.0619398 0.473101 0.204024 0.784434 0.72608 0.92305 0.100044 0.815554 0.161155 0.416701 [:, :, 2] = 0.305238 0.530652 0.74287 0.484455 0.0904463 0.105327 0.0632765 0.818537 0.704337 0.152749 0.0189906 0.120929 创建副本防止绑定更新 使用=生产的新Arrays，内存地址上和原来的Arrays是相同的，因此会同时更新 julia> fibonacci 7-element Array{Int64,1}: 1 1 2 3 5 8 13 julia> somenumbers = fibonacci 7-element Array{Int64,1}: 1 1 2 3 5 8 13 julia> somenumbers[1] = 404 404 julia> fibonacci 7-element Array{Int64,1}: 404 1 2 3 5 8 13 若要防止此情况，使用copy创建新的Arrays julia> fibonacci 7-element Array{Int64,1}: 1 1 2 3 5 8 13 julia> somemorenumbers = copy(fibonacci) 7-element Array{Int64,1}: 1 1 2 3 5 8 13 julia> somemorenumbers[1] = 404 404 julia> fibonacci 7-element Array{Int64,1}: 1 1 2 3 5 8 13 Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 02:21:50 "},"julia_study/Base/Control_flow.html":{"url":"julia_study/Base/Control_flow.html","title":"Control_flow","summary":"Julia控制句法","keywords":"","body":"Control flow While循环语句 while *condition* *loop body* end 举例 while n 1 2 3 4 5 6 7 8 9 10 10 myfriends = [\"Ted\", \"Robyn\", \"Barney\", \"Lily\", \"Marshall\"] i = 1 while i Hi Ted, it's great to see you! Hi Robyn, it's great to see you! Hi Barney, it's great to see you! Hi Lily, it's great to see you! Hi Marshall, it's great to see you! For循环语句 for *var* in *loop iterable* *loop body* end 举例 myfriends = [\"Ted\", \"Robyn\", \"Barney\", \"Lily\", \"Marshall\"] for friend in myfriends println(\"Hi $friend, it's great to see you!\") end >Hi Ted, it's great to see you! Hi Robyn, it's great to see you! Hi Barney, it's great to see you! Hi Lily, it's great to see you! Hi Marshall, it's great to see you! m, n = 5, 5 A = fill(0, (m, n)) >5×5 Array{Int64,2}: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 for i in 1:m for j in 1:n A[i, j] = i + j end end A >5×5 Array{Int64,2}: 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 5 6 7 8 9 6 7 8 9 10 for语句的其他形式 B = fill(0, (m, n)) >5×5 Array{Int64,2}: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 for i in 1:m, j in 1:n B[i, j] = i + j end B >5×5 Array{Int64,2}: 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 5 6 7 8 9 6 7 8 9 10 C = [i + j for i in 1:m, j in 1:n] >5×5 Array{Int64,2}: 2 3 4 5 6 3 4 5 6 7 4 5 6 7 8 5 6 7 8 9 6 7 8 9 10 If条件语句 if *condition 1* *option 1* elseif *condition 2* *option 2* else *option 3* end 举例 julia> N =4 4 julia> if (N % 3 == 0) && (N % 5 == 0) # `&&` means \"AND\"; % computes the remainder after division println(\"FizzBuzz\") elseif N % 3 == 0 println(\"Fizz\") elseif N % 5 == 0 println(\"Buzz\") else println(N) end 4 if语句的其他形式 三元运算符 a ? b : c 这等同于 if a b else c end 使用语句连接符 julia> x=3 3 julia> (x > 0) && error(\"x cannot be greater than 0\") ERROR: x cannot be greater than 0 Stacktrace: [1] error(::String) at ./error.jl:33 [2] top-level scope at REPL[8]:1 julia> x=-4 -4 julia> (x > 0) && error(\"x cannot be greater than 0\") false julia> true || println(\"hi\") true julia> false || println(\"hi\") hi Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 02:21:50 "},"julia_study/Flux/":{"url":"julia_study/Flux/","title":"Flux","summary":"Julia Flux Pkg的学习笔记","keywords":"","body":"Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 02:21:50 "},"julia_study/Flux/Fuctions.html":{"url":"julia_study/Flux/Fuctions.html","title":"Fuctions","summary":"Julia Flux Pkg中的函数用法","keywords":"","body":"Fuctions gradient 求导函数，亦称求梯度函数 基本用法 df(x) = gradient(f, x) df为导函数，f为原函数，x为求导变量 gradient(f, [2, 1], [2, 0]) f为原函数，后面两个数组为函数的两个参数向量，该语句返回函数在某一点的导数（梯度） gs=gradient(params(x, y)) do f(x, y) end 通过处理参数集合params来获取导数 params 返回函数参数的函数 update! 按照一定的方式更新网络参数 Copyright © jerrywang 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-04-17 02:21:50 "}}